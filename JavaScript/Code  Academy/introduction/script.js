// რა რის console?

// პითონში როგორც გვაქვს print() ფუნქცია იგივე როლს ასრულებს 
console.log();
// მასში ჩაწერილი ნებისმიერი არგუმენტი გამოვა ან console-ში ან html-ის inspect-ში



// ---------------------------------------------------------------------------------------------------------------------------------------------------




// კომენტარები JavaScript-ში

// 1. "//" სათითაო გაზზე იწერება ორი ხაზით. 

// 2. "/*  */" --> მრავალ ხაზზე შეგვიძლია დავწეროთ 




// ---------------------------------------------------------------------------------------------------------------------------------------------------





// Data Types - მონაცემთა ტიპები 

// 1. Number --> ნებისმიერი რიცხვი როგორც მტელი ისე წილადური მაგ მაგ: (12, 34, 25.5)

// 2. String --> ნებისმიერიმონაცემი რომელიც ჩასმულია ან წყვილ ბრჭყალებში ( " " ) ან ცალ ბრჭყალებში ( ' ' )
// მაგ: ("გვანცა", '123' )


/* 3. Boolean --> მონაცემის ტიპი რომელსაც გააჩნია მხოლოდ ორი მნიშვნელობა: */ 

true  && false;
// ისინი ყოველთვის იქერება პატარა ასოებში 


// 4. Null --> როდესაც არ არსებობს მისი მნიშვნელობა 

// 5. Undefined --> არ არსებობს მონაცემის ტიპი

// 6.  Objects --> მონაცემების კოლექცია

// 7. NaN --> არ არის რიცხვი 



// ---------------------------------------------------------------------------------------------------------------------------------------------------


// Arithmetic Operators - არითმეტიკული ოპერატორები

// Add -->  +
console.log(5 + 5);

// Subtract --> -
console.log(5 - 5);

// Multyply --> *
console.log(5 * 5);

// Divide --> / --> ნაშთიანი გაყოფა
console.log(5 / 5);

// Remainder --> % -- უნაშთო გაყოფა 
console.log(5 % 5);




// ---------------------------------------------------------------------------------------------------------------------------------------------------


// String Concatenation

console.log("Gvanca " + 'Mazanishvili');

// ---------------------------------------------------------------------------------------------------------------------------------------------------



// How to create Variable? 

// 1. "let" --> key word როდესაც ჩვენ ვიყენებთ let-ს იმისთვის რომ შევქმმნაც ცვლადი, ჩვენ შეგვიძლია რომ მას შევუცვალოთ მნიშვნელობა. 

let name = "gvanca";

name = 'barbare';
console.log(name); // output = barbare


// 2. "const" --> key word როდესაც ვიყენებთ const-ს იგივე (constant) იმისთვის რომ შევქმნაც ცვლადი,  მისი ცვლადის შეცვლა არ შეგვიძლია 
const num = 12;
num = 29;

console.log(num); // output = TypeError: Assignment to constant variable.



// ---------------------------------------------------------------------------------------------------------------------------------------------------





// Properties and methods - კუთვნილებები და მეთოდები 


// .length --> გვიჩვენებს სიგრძეს
// .concat() --> ხდება კოკატინაცია და აერთებს ორ სტრინგს ერთმანეთთან
// .indexOf() --> გადაცეულ არგუმენტის პირველ ინდექსს აბრულებს
// .lastIndexOf() --> გადაცემული არგუმენტის ინდექსს აბრუნებს
// .split(" ") --> ფრჩხილებში გადაცემული არგუმენტი ყოფს string-ს და გარდაქმნის მას list მონაცემის ტიპად
// .toLowerCase() --> გადააქვს გადაცემული სტრინგი პატარა ასოებში
// .toUpperCase() --> გადააქვს გადაცემული სტრინგი დიდ ასებში
// .trim() --> აშორებს ყველანაირ გამოტოვებებს
// .trimStart() --> აშორებს გამოტოვებებს მხოლოდ დასაწყისში
// .trimEnd() --> აშორებს გამოტოვებებს მხოლოდ დასასრულს
// .startsWith() --> აბრუნებს Boolean მნიშვნელობას  true ან false და ამოწმებს იწყება თუ არა ამა თუ იმ ასოზე.
// .endsWith() --> აბრუნებს Boolean მნიშვნელობას  true ან false და ამოწმებს მთავრდება თუ არა ამა თუ იმ ასოზე.
// .push() --> შეგვიძლია სიაში დავამატოთ მნიშვნელობები. მას შეგვიძლია გადავცეთ ბევრი არგუმენტი რომელსაც გამოვყობთ მძიმით 
// .pop() --> შეგვიძლია სიიდან ამოვაგდოთ ბოლო მნიშნელობა რადგან ის არ იღებს არგუმენტს 
// .slice() --> იღებს მასივის ნაწილს და აბრუნებს ახალ მასივს. არ ცვლის ორიგინალ მასივს. მას გადაეცემა ორი არგუმენტი: პირველი საიდანაც უნდა დაიწყოს ამოჭრა, და მეორე რომელ index-ამდე ამოჭრას 
// .shift() --> შლის მასივის პირველ ელემენტს. ცვლის ორიგინალ მასივს.
// .unshift() --> ამატებს ელემენტებს მასივის დასაწყისში. ცვლის ორიგინალ მასივს.
// .splice() --> შეგვიძლია წავშალოთ ელემენტები სიაში. მას გადაეცემა ორი არგუმენტი: პირველი ინდექსი საიდანაც უნდა დაიწყოს წაშლა ხოლო მეორე, მის ჩათვლით კიდევ რამდენი ელემენტი ამოშალოს. თუ არ გადავცემთ მეორე არგუმენტს ავტომატირად მხოლოდ ერთი წაიშლება 



// ---------------------------------------------------------------------------------------------------------------------------------------------------





// Mathematical Methods  - მათემატიკური მეთოდები 

// Math.round() --> ამრგვალებს ყველაზე ახლო რიცხვთან
// Math.ceil() --> ამრგვალებს ზემოთ
// Math.floor() --> ამბრგვაკებს ქვემოთ
// Math.pow() --> გადაეცემა ორი მნიჩვნელობა და გამოიყოფა მძიმით. ახარისხება ხდება (მაგ: Math.pow(2, 3) --> 8)
// Math.random() --> აგენერირებს რიცხვებს 0-დან 1-მდე ნებისმიერს. თუ მას კოდის გამოყენებისას გავამრავლებთ რაიმე რიცხვზე იგი მხოლოდ იმ რიცხვამდე დააგენერირებს რიცხვებს 
// Math.abs() --> აბრუნებს რიცხვის დადებით მნიშვნელობას


// ---------------------------------------------------------------------------------------------------------------------------------------------------





// Mathematical Assignment Operators - მათმატიკური მინიჭების ოპერატორები 

// = -->  უდრის
// == --> უდრისი რომლის დროსაც მოწმდება მისი მნიშვნელობა მხოლოდ 
// === --> მკაცრი ტოლობა, მომწმდება არა მარტო მნიშვნელობა არამედ მონაცემის ტიპიც 
// != --> არ უდრის 
// !== --> მკაცრი არ უდრის
// += --> ყოველი კონკრეტული მოქმედების შემდეგ დამატება
// -= --> ყოველი კონკრეტული მოქმედების შემდეგ გამოკლება
// *= -->  ყოველი კონკრეტული მოქმედების შემდეგ გამრავლება
// /= -->  ყოველი კონკრეტული მოქმედების შემდეგ გაყოფა
// >= --> მეტია ან ტოლი
// <= --> ნაკლებია ან ტოლი
// > --> მეტია
// < --> ნაკლები




// ---------------------------------------------------------------------------------------------------------------------------------------------------




// The Increment and Decrement Operator - ინკრემენტ და დეკრამენტ ოპერატორი 


// Increment --> გაზრა ერთით ++
const x = 9;
x ++
console.log(x); // 10

// Decrement --> შემცირება ერთით --
const y = 10
x --
console.log(y); // 9




// ---------------------------------------------------------------------------------------------------------------------------------------------------





// String Literal --- Template literal 

// როგორც პითონში f"" f string ისეთივეა String literal 

// syntax: 
// `` - backticks -  ჰაეროვანი ფრჩხილები
// ${} - გამოიყენება ცვლადების ჩასასმელად 

// გამოყენება: 

const word = "i love";
const word2 = "Yiyliyo";

console.log(`${word} ${word2}`);



// ---------------------------------------------------------------------------------------------------------------------------------------------------



// typeOf oprator - რა მონაცემის ტიპია?

// ამოწმებს რომელი ტიპისაა ესა თუ ის მონაცემი
// გამოყენება:

console.log(typeof 12) // number 




// ---------------------------------------------------------------------------------------------------------------------------------------------------



/* Conditional Statements - პირობითი განცხადებები 

    if... else statement 

    () ფრჩხილებში ჩაიწერება ის პიტობა რომლის მიხედვითაც გაეშვება კოდი.
    ხოლო შედეგს ჩვენ ვწერთ {} --> ფრჩხილებში

    ჩვენ შეგვიძლია else if პირდაპიტ მივუწეროთ მის წინამორბედ პირობას როგოც მოცემულია მაგალითში 
*/ 


// გამოყენება:  
let age = 18;

if (age < 13) {
    console.log("You're a child");
} else if (age < 18) {
    console.log("You're a teenager");
} else if (age < 65) {
    console.log("You're an adult");
} else {
    onsole.log("You're a senior");
}



// ---------------------------------------------------------------------------------------------------------------------------------------------------




// Logical operators - ლოგიკური ოპერატორები



//the and operator ( && ) -  გეაშვება true როდესაც შედარების კოდის ორივე მხარე სიმართლეა

if (stopLight === 'green' && pedestrians === 0) {
    console.log('Go!');
} else {
    console.log('Stop');
}

// the or operator ( || ) - გეაშვება true როდესაც შედარების კოდის ერთ-ერთი მხარე სიმართლეა

if (day === 'Saturday' || day === 'Sunday') {
    console.log('Enjoy the weekend!');
} else {
    console.log('Do some work.');
}

// the not operator, otherwise known as the bang operator ( ! ) - აბრუნებს საპირისპირო მნიშვნელობას 

let excited = true;
console.log(!excited); //  false

let sleepy = false;
console.log(!sleepy); //  true




// ---------------------------------------------------------------------------------------------------------------------------------------------------




// Ternary Operator - ტერნარი ოპერატორი 

// if else-ის შემოკლებული ვარიანტია ტერნარი ოპერატორი 

isNightTime ? console.log('Turn on the lights!') : console.log('Turn off the lights!');

/* 
1. კითხვის ნიშნამდე არის ის რაც უნდა შემოწმდეს 
2. პირველი კოდი --> console.log('Turn on the lights!') --- გაეშვება მაშინ თუ პირობა არის სიმართლე.
3. true და false გამოყოფილია ":" ორ წერტილით 
4. console.log('Turn off the lights!'); --> გაეშვება მაშინ როდესაც მისი მნიშვნელობა იქნება false
*/



// ---------------------------------------------------------------------------------------------------------------------------------------------------



// The switch keyword --- შეცვლა 

// იყენებს სამ key word-ს; 
// switch () --> ფრჩხილებში ჩაწერილს ამოწმებს 
// case -->  ანუ შემთხვევა 
// default --> თუ ზემოთ მოცემული შემთხვევებიდან არც ერთი არ გაეშვა

let groceryItem = 'papaya';

switch (groceryItem) {
    case 'tomato':
    console.log('Tomatoes are $0.49');
        break;
    case 'lime':
    console.log('Limes are $1.49');
        break;
    case 'papaya':
    console.log('Papayas are $1.29');
        break;
    default:
    console.log('Invalid item');
        break;
}





// ---------------------------------------------------------------------------------------------------------------------------------------------------




// Functions - ფუნქციები

// ფუნქცი არის მრავალ გამოყენებადი კოდის ბლოკი რომელაც გააცნია მხოლოდ კონკრედული დავალება



// Function Declarations - ფუნქციის დეკლარაცია 


// ფუნქციის შესაქმნელად ვიყენებთ function keword-ს, მის შემდეგ ვწერთ უკვე ფუნქციის სახელს, ორ ფრჩხილს და { } - ფუგურულ ფრჩხილებს
// მაგალითად:


function greetWorld() {
    console.log('Hello, World!');
}





// Calling a function - ფუნქციის გამოძახება 

// ფუნქციის გამოსაძახებლად ჩვენ ვიყენებთ თავად ფუნქციის სახელს, ფრჩხილებს და წერტილ-მძიმეს.
// მაგალითად: 
greetWorld();






// Parameters and Arguments  - პარამეტრები და არგუმენტები 

// Parameters - პარამეტრები არის ის რომელიც ფუნქციის ახელის შემდეგ არსებულ ფრჩხილებში იწერება, რომელიც შემდგომ უნდა გადავცეთ.

// Arguments - არგუმენტები კი არის ის მნიშვნელობები რომლემსაც გადავცემთ გამოძახების შემდეგ 

// მაგალითად:

function sayThanks(name) {
    console.log('Thank you for your purchase, '+ name + '! We appreciate your business.'
);
}

sayThanks('Cole')




// default Parameters - საწყისი პარამეტრები 

// იმ შემთხვევაში თუ არ გადავცემთ რაიმე არგუმენტს გამოძახებისას ჩვენ შეგვიძლია რომ პარამეტრებშივე გავუწეროთ საწყისი მნიშვნელობა რომ თუ არგუმენტი არ არსებობს მაშნ დააბრუნოს საწისი პარამეტრი 

function greeting (name = 'stranger') {
    console.log(`Hello, ${name}!`)
}

greeting('Nick') // Hello, Nick!
greeting() // Hello, stranger!






// return - უკან დაბრუნება 

// მნიშვნელობას აბრუნებს ფუნქციაშივე

// მაგალითად:

function rectangleArea(width, height) {
    if (width < 0 || height < 0) {
    return 'You need positive integers to calculate area!';
}

    return width * height;
}






// Helper functions - დამხმარე ფუნქციები 

// დამხმარე ფუნქციები არიან ისეთი ფუნქციები რომელსაც გააჩნიათ მარტივი, მცირე დავალება რომლითაც დახმარება შეუძლიათ სხვა ფუნქციისთვის

// მაგალითად:

function multiplyByNineFifths(number) {
    return number * (9/5);
};

function getFahrenheit(celsius) {
    return multiplyByNineFifths(celsius) + 32;
};

getFahrenheit(15); // Returns 59





// Function expresions - ფუნქციის გამოხატვა 

/* ჩვენ შეგვიძლია რომ ფუნქია შევინახოთ ცვლადში რის შედეგადაც ჩვენ აღარ გვიწევს რომ ფუნქცის კიდევ ცალკე დავარქვათ რაიმე სახელი. ასეთ ფუნქციებს Anonymous Functions ეწოდება, ანუ მას არ გააჩნია ფუნქციის სახელი. */


// მაგალითად: 

const plantNeedsWater = function(day){
    if (day === 'Wednesday'){
        return true
    } else{
        return false
    }
}

console.log(plantNeedsWater('Tuesday'))





// Arrow Functions - ისრის ფუნქციები 

/* ისრის ფუნქვიები იწარმოება ეგრედ წოდებული "მსუქანი ისრის" დახმარებით რომელიც ასე იწერება --> ( => ). 

ისრის ფუნქცია საშვალებას გვაძლევს რომ უფრო შემოკლებით დავწეროთ კოდი და ასევე საშვალბას გვაძლებს რომ function keyword აღარ გამოვიყენოთ. 

სინტაქსი: () => {
    
} */

const rectangleArea = (width, height) => {
  let area = width * height;
    return area;
};






// Concise Body Arrow Functions - კონცენტრირებული ისრის ფუნცია 


/* ჩვენ შეგვიძლია ისრის ფუნქცია კიდევ უფრო მოკლედ დავწეროთ. ის ეყრდნობა ორ მაგალითს და წესს. 
*/

// 1.  თუ ფუნქციას სჭირდება ერთი პარამეტრი მასინ არ არის საჭირო ფრჩხილების დაწერა და პირდაპირ შეგვიძლია გავუტოლოთ მას ფუნქციის სხეული 

// მაგალითად: 
const functionName = paramOne => {};

// 2. იმ შემთხვევაში თუ ქუნციას არ გადაეცემა არანაირი პარამეტრი ანდა ერთზე მეტი პარამეტრი მაშინ აუციებელია რომ მას მივუწეროთ ფრჩხილები

// მაგალითად:
const FunctionName = () => {};

const FuncName = (paramOne, ParamTwo) => {};





// single-line Function - ერთ ხაზში დაწერილი ფუნცია 

// იმ შემთხვევაშ თუ ჩვენი ფუნქცია მარტივი შეგვიძლია ჩვენ ის დავწეროთ ერთ ხაზში რომელიც აღარ საჭიროებს return-ს

// მაგალითად: 

const Adding = number => number + number





// ---------------------------------------------------------------------------------------------------------------------------------------------------



// Scope - სკოუპი ანუ ხილვადობის არეალი 

// Scope-ი განსაზღვარვს თუ სად შეიძლება ცვლადზე წვდომის მოპოვება ან მათი პროგრამაში გამოყენება 



// Global Scope - გლობალური Scope 

// გლობალური სკოუპის დროს ჩვენ ცვლადს ვქნით კოდის ბლოკის გარეთ რაც ნიშნავს იმას რომ ისინი არ არიან დამოკიდებულები ფუნციაზე და ნებისმიერ ადგილიდან შეგვიძლია გამოვიძახოთ 

// მაგალითად:

const color = 'blue';

const returnSkyColor = () => {
    return color; // blue 
};

console.log(returnSkyColor()); // blue





// Block Scope - ბლოკური სკოუპი

// ბლოკის სკოუპი ნიშნავს რომ ცვლადი სექმნილია კონკრეტული ფუნქციის შიგნით რაც ნიშნავს იმას რომ ფუნციის გარეთ არ გვექნება მასთან წვდომა -  ასეთ ცვლადებს Local Variables უწოდებენ 

// მაგალითად:

const logSkyColor = () => {
    let color = 'blue'; 
    console.log(color); // Prints "blue"
};

logSkyColor(); // Prints "blue"
console.log(color); // throws a ReferenceError - გამოაქვს ერორი 


// Scope Pollution - სკოუპის დაბინძურება 

// დაბინძურება მშინ ხდება როდესაც ძალიან ბევრი ცვლადი იქნმნება global-ურად ანდა ამ ცვლადებს ძალიან ხშირად ვიყენებთ სხვადასხვა ფუნქციებში 

// მაგალითად:

let Num = 50;

const logNum = () => {
  Num = 100; // Take note of this line of code
    console.log(Num);
};

logNum(); // Prints 100
console.log(Num); // Prints 100




// ---------------------------------------------------------------------------------------------------------------------------------------------------





// Arrays - მასივები, სიები

// მასივების შესაქმნელად ჩვენ გვჭირდება ცვლადი და [] - კვადრატული ფრჩხილები. სიაბში ინსახება ნებისმიერი მონაცემის ტიპი და ისინი ერთმანეთისგან გამოიყოფა მძიმეებით

// მაგალითად:
let newYearsResolutions = ['Keep a journal', 'Take a falconry class', 'Learn to juggle'];




// Accessing Elements - ელემენტებთან წვდომა 

/* იმითვის რომ მივწვდეთ ჩვენ სიაში არსებულ მონაცემებს ამისთვის ჩვენ დახვშირდება სიის სახელი და index-ი იმ ელემენტის რომლისთვისაც გვჭირდება წვდობა.

indexing - სიებიში ნათმიმდევრობის ათვლა იწყება 0-დან ამიტომაც თუ სიაში გვაქვს 5 ელემენტი მაშინ ბოლო, მეხუთე ელემენტის index-ი იქნება 4. */

console.log(newYearsResolutions[2]) // 'Learn to juggle'

// ვიყენებთ კვადრატულ ფრჩხილებს რომელშიც ვწერთ თუ რომელი ინედქსი გვინდა რომ გამოიტანოს 




// Update Elements  -  ელემენტების განახლება 

/* იმისთვის რომ განვანახლოთ სიაში მონაცემი ამისთვის ვიყენებთ სიის სახელს, მის ინდექტსს და ამ ყველაფერს ვუტოლებთ იმ მნიშვნელობას როთაც უნდა ჩავანაცვლოთ ელემენტი */

// მაგალითად: 

let seasons = ['Winter', 'Spring', 'Summer', 'Fall'];

seasons[3] = 'Autumn';
console.log(seasons); 

// ['Winter', 'Spring', 'Summer', 'Autumn']





// Arrays with let and const - მასივები let-ით და const-ით

// თუ მასივს შევქმნით const keyword-ით მაშინ ის შეუცვლელი იქნება 
// თუ მასივს შევქმნით let keyword-ით მაშინ მისი შეცვლა შეგვეძლება



// Nested Arrays - ჩაშენებული სიები 

// ჩვენ შეგვუძლია ჩავაშენოთ სიები სიაში 

// მაგალითად:
const nestedArr = [[1], [2, 3]];

console.log(nestedArr[1]); // [2, 3]





// ---------------------------------------------------------------------------------------------------------------------------------------------------




// Loops - ციკლები

// ციკლები არიან კოდის ბლოკები რომელიც რაღაც პირობის დაყრდნობით ის უშვებს პროგრამას. ეს პროგრამა კი მანამდე იტრიალებს სანამ მის პირობას არ მიწხვდება 


// For loop  - ციკლი რომლის დროსაც ვიცით დიაპაზნი რამდენიც ვ=გვჭირდება 


for (let counter = 0; counter < 4; counter++) {
    console.log(counter);
}

/* for --> keyword
(let counter = 0; counter < 4; counter++) --> პირობა რომელსაც მიყვება კოდი 
let counter = 0; --> საწისი ცვლადი რომელიც არის ათვლის რიცხვი ანუ start
counter < 4 --> დასასრული, სად უნდა დამთავრდეს ციკლი ანუ end
counter++ --> ყოველი ინტერაციის მერე რომ მოემატოს ციფრი რომ ჩვენმმა ციკლმა უსასრულოდ არ იტრიალოს ანუ step  */



// Looping through Arrays - ციკლები სიებიში 


const animals = ['Grizzly Bear', 'Sloth', 'Sea Lion'];
for (let i = 0; i < animals.length; i++){
    onsole.log(animals[i]);
}

// output of the code above:


/*
Grizzly Bear
Sloth
Sea Lion
*/




// Nested Loops - ჩაშენებული ციკლები

// ჩაშენებილი ციკლები ხდება მაშინ როდესაც ვადარებთ ორ სიას ერთმანეთთან

// მაგალითდ: 

const arrayA = [6, 19, 20];
const arrayB = [19, 81, 2];

for (let i = 0; i < arrayA.length; i++) {

    for (let j = 0; j < arrayB.length; j++) {

        if (arrayA[i] === arrayB[j]) {
                console.log('Both arrays have the number: ' +   arrayB[j]);
        }
    } 
}




// While loop - სანამ ციკლი 

// გამოიყენება მაშინ როდესაც ჩვენ არ ვიცით ზუსტად რამდენი ინტერაციია საჭირო 

// მაგალითად:

let counterTwo = 1;

while (counterTwo < 4) {
    console.log(counterTwo);
    counterTwo++;
}



// let counterTwo = 1; --> იქმნება საწყისი ათვლის ცვლადი იმისთვის რომ ჩვენი ციკლი არ გაგრძელდეს სამუდამოდ 
// while --> სანამ ციკლის keyword 
// (counterTwo < 4) --> პირობას რომელსაც უნდა გაყვეს ჩვენი ციკლი 
// counterTwo++; --> ყოველ ინეტრაციაზე ამატებს ერთს ჩვენს counterTwo ცვლადში 



// Do...While Statements - გააკეთე, სანამ

// do while --> ციკლის keyword-ები გამოიყენება მაშინ როდესაც ჩვენ გვინდა რომ სანამ ციკლი გაეშვება სხვა კოდი გაეშვას 

// მაგალითად:

let countString = '';
let i = 0;

do {
    countString = countString + i;
    i++;
} while (i < 5);

console.log(countString);

// ვქმნით ორ ცვლად სახელად countString და i, do{}-ს ტანში გვიწყერია რომ დაამატოს რიცხვი თითო-თითო სანამ, while ჩვენი i ცვლადი ნაკლებია 5-ზე




// The break Keyword - შეჩერების სიტყვა 

// break; --> დიდი ინტერაციის ციკლების დროს ჩვენ შეგვიძლია შევაცეროთ ესა თუ ის ციკლი 

for (let i = 0; i < 99; i++) {
    if (i > 2 ) {
            break;
        }
    console.log('Banana.');
}

console.log('Orange you glad I broke out the loop!');
// ციკლი ჩერდება როდესაც ჩვენი i ცვლადი ხდება 2-ზე მეტი




// ---------------------------------------------------------------------------------------------------------------------------------------------------




