# Tuple - თაფლები 
# თაფლები არის ისეთი მონაცემის ტიპი რომელიც იქმნება, ცვლადისა და () - ჩოულებრივი ფრჩხილებისგან 

# თაფლები არიან immutable რომელიც ნიშნავს რომ მისი შეცვლა არ შეგვიძლია 

# მაგ:
import keyword


name = ("Gvanca", "Giorgi", "Barbare")

# თაფლებში დასაშვები ფუნქციები
# count(), len(), find(), index()

# არ შეგვიძლია გამოყენება 
# .append(), .pop(), .insert(), .remove(), .sort(), .reverse(), sorted(), reversed()


# packing - მნიშვნელობების ჩასმა tuple-ში 


# unpacking - მნიშვნელობების გამოტანა გარეთ 
fruits = ('Pear', 'Apple', 'mango', 'watermelon')
fruits1, fruit2, fruit3, fruits4 = fruits

# ვქმნით ცვლადებს რომლსაც ვანიჭებთ მნიშვნელობებს თაფლიდან 

# * - ასტერიქსი, მისი დაწერა შეგვიძლია მხოლოდ ერთხელ გამოიყენება და ის ასრულებს იგივე ობოლთა თავშესაფარის როლს და მიუნიჭებელ მნიშვნელობებს სიის სახით აბრუნებს.

# მაგ:

scores = (98, 96, 91, 88, 64)
winner, *rest = scores
print(winner) # 98
print(rest) # [96, 91, 88, 64]





#---------------------------------------------------------------------------------------------------------------------------------------------------






# sets - სეტები 

# სეთები არის მონაცემის სტრუქტურის ერთ ერთი ტიპი, რომლის დროსაც ვიყენებთ ცვლადს და {} - ფიგურულ ფრჩხილებს

# მისი თვისებები:

# 1. მას ინექსი არ გააჩნია
# 2. დაპრინტვის დროს set-ი აშორებს ტუბლიკატებს 
print(set({2, 2, 2, 2198, 2938})) # {2938, 2, 2198}




# Methods in Sets -  მეთოდები სეთბში 

# .set() - ფუნცია გარდაქმნის მონაცემს სეთად გარდაქმნის 
# .add() - ამატებს ელემენტებს
# .remove() - შეგვიძლია ამოვშალოთ ელემენტების სახელების ჩაწერით  
# .clear() - ასუფთავებს მთლიან სეთს 
# .union() - ორი სეთის გაერთიანება. 
set1 = {1, 2, 3}
set2 = {3, 4, 5}
result = set1.union(set2)

# difference() - განსხვავება, დააბრუნებს მხოლოდ იმ ელემენტებს რომლებიც არიან პირველ სეთში და არა მეორეში 
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
result = set1.difference(set2) # {1, 2}





#---------------------------------------------------------------------------------------------------------------------------------------------------



# dictionaries - დიქტები
# ც=ვლადში ვინახავთ {} - ფიგურულ ფრჩხილებში key და value წყვილებს რომლებიც ინახავენ მონაცემებს 
# მაგ:

personal = {
    'name': "Gvanca",
    'surname': "Mazanishvili",
    'age': 15
}

# მარცხნივ ჩამოთვლილი name, surname, age არიან key მნიშნელობები რომლებიც გამოყოფილია მისი მნიშვნელობებისგან ("Gvanca", 'Mazanisvhili', 15) ორ წერტილით, ხოლო თვითონ ეს ობიქტები ცალცალკე
# გამოიყოფა მძიმეებით
#    'name': "Gvanca", 
#    'surname': "Mazanishvili",
#    'age': 15


# Methods in Dictionaries - მეთოდები 

# .get() --> შეგვიძლია მივწყვდეთ მნიშვნელობებს
personal_info = personal.get('name')
print(personal_info) # Gvanca

# .keys() --> გამოაქვს ყველა key მნიშვნელობა 
print(personal.keys()) # dict_keys(['name', 'surname', 'age'])

# .items() --> გამოაქვს ყველა ინფორმაცია რაც კი არის დიქტში 
print(personal.items()) # dict_items([('name', 'Gvanca'), ('surname', 'Mazanishvili'), ('age', 15)])

# .values() --> გამოაქვს ყველა მნიშვნელობა 
print(personal.values()) # dict_values(['Gvanca', 'Mazanishvili', 15])

# update({}) --> შეგვიძლია დავამატოთ დიქტში რაიმე მონაცემი
personal.update({'birthday': 11})
print(personal) # {'name': 'Gvanca', 'surname': 'Mazanishvili', 'age': 15, 'birthday': 11}


# როგორ შევამოწმოთ არის თუ არა მნიშვნელობა დიქსტში?

for i in personal:
    print(personal.values())  # dict_values(['Gvanca', 'Mazanishvili', 15, 11])





#---------------------------------------------------------------------------------------------------------------------------------------------------





# List comprehensions - სიის შემოკლება 

# list comprehension-ის გამოყენებით ჩვენ შეგვიძლია შევამოკლოდ კოდი
# მაგ:

# Normal way 
num =  []
for i in range(50):
    if i % 2 == 0:
        num.append(i)  
print(num)

# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]



# Using list comprehensions 
nums = [i for i in range(50) if i % 2 == 0]
print(nums)

# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]


# nums - ცვლადში ინახება მთლიანი სია რომლშიც ვწერთ შემოწმებას
# პირველი i არის ის მნიშვნელობა რომელსაც ვამატებთ სიაში, ხოლო მის მერე დაწერილი:  for i in range(50) ჩოულებრივ იწერებე.
# მის მერე კი ვწერთ if რომელიშიც პროგრამას ვეუბნებით რომ მხოლოდ ისინი დაამატო რომელიც ორზე იყოფა.

# list comprehension - დროს არ ვიყენებთ არანაირ ინდენტაციებს 





#---------------------------------------------------------------------------------------------------------------------------------------------------





# Exceptions - გამოთაკლისები

# პროგრამებში არსებობს სხვადასხვა ტიპის ერორები
# Errors იყოფა ორ ჯგუფად: სინტაქტსური და გამონაკლისები

# syntax - მცირე შეცდომები კოდში
# Exceptions - კოდი გაიშვება თუმცა რაღც ხელს შეუშლია მის სრულყოფილ გაშვებაში და ჩერდება კოდი 

# Exception examples:
# SyntaxError --> სინტაქსური ერორი, დაწერაშია შეცდომა
# IndexError --> ინდექსი არის საზღვრებს გარეთ
# ValueError --> მნიშვნელობა არის არასწორი 
# NameError --> სახელი აქვს არასწორად დარქმეული, ან არ არსებობს 
# TypeError --> მონაცემთა ტიპის ერორი 
# IndentationError --> ინდენტაციის ერორი 
# ZeroDivisionError --> ნულზე გაყოფა არ შეიძლება 


# Try and except Keywords:
# try and except ვიყენებთ მაშინ როდესაც გვინდა სატესტო გარემო შევქმნათ და ერორი დაიჭიროს 
# მაგ:


try:
    num1  = int(input("Enter a number: "))
    num2  = int(input("Enter a number: "))
    print(num1 / num2)
except ValueError:
    print("invalid Data")
except ZeroDivisionError:
    print("You can't divide by zero")

# კოდის გაშვებისას კოდი ეცდება შემოტანილი რიცხვები გაყოს. გამონაკლისით თუ არასწორ მონაცემს შეიტანს და გამონაკლისი ნულზე გაყოფა არ შეიძლება 



# Finally - საბოლოოდ 
# საბოლოო keyword რომელიც გაეშვება იმის და მიუხედავათ ექნება ერორი კოდს თუ არა

try:
    phone_n = int(input("Enter your phone number: "))
except ValueError:
    print("Use the correct format: ")
finally:
    print("contact anytime: ")


#  Raise and Else keywords
# ერორების გამოსაწვევად ჩვენ შეგვიძლია გამოვიყენოთ raise keyword
# else-ში შეგვიცლია ჩავსვათ finally-ის მაგივრად


def check_password(password):
    try:
        if len(password) < 8:
            raise Exception("Password too short") # გამოიტანოს ერორი რომ პაროლი პატარაა
        elif ' ' in password:
            raise Exception("Password cannot contain spaces") # გამოიტანოს ერორი როდესაც გამოტოვებები გამოყენებული 
    except ValueError:
        return 'Error Encountered'
    else:
        return "Password accepted"

print(check_password('12345678'))







#---------------------------------------------------------------------------------------------------------------------------------------------------




# functions in python - ფუნქციები პითონში 
# პითონში არსებობს სამი სახლის ფუნქციები: High-order, Pure-functions, Impure-functions


# High-order - ფუნცია რომელიც არგუმენტად იღებს სხვა ფუნქციას 
def repeat(n, action):
    for i in range(n):
        action(i)


# Pure-Functions - წმინდა მუნქცია რომელის input და output-ს ერთნაირს გვაძლევს და არანაირ დახმარებას არ იღებს ფუნქციის გარედან 
def add(a, b):
    return a + b


# Impure-functions  - ფუნქცია რომლიც გარეთ არსებულ კოდზე ახდენს გავლენას 
discount = 0.1
def apply_discount(price):
    return price - (price * discount)







#---------------------------------------------------------------------------------------------------------------------------------------------------





# Lambda Expresions  - ლამბდას გამოსახულებები 


# lambda - ის არის high-order function და მას მეორე ნაირად უწოდებენ ანონიმურ ფუნქციას რადგან მას სახელი არ გადაეცემა. მას მხოლოდ მატარა მარტივი დავალებები შესრულება შეუძლია 

# მაგ:
multiply  = lambda num: num * 5
# ის შევინახეთ ცვლადში სახელად multiply და გავუტოლეთ მას lambda ფუნქცია. ფუნციის მერე არსებული num არის მისი პარამეტრი რომელიც ფუნქციის "ტანისაგან" არის გამოტოვებული ორწერტილით. მის შემდეგ კი არის თვითონ მოქმედება რომელიც უნდა აწარმოოს გადაცემულ რიცხვზე 

print(multiply(5)) # 25

# lambda-ს ერთზე მეტი პარამეტრი შეგვიძლია გადავცეთ 

add = lambda num1, num2: num1 + num2
print(add(5, 5)) # 10

